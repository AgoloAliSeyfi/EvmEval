<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>EvmEval by hunterhector</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>EvmEval</h1>
        <p>The event mention detection and corefrene evaluators, and associated utilities (converters, validators)</p>

        <p class="view"><a href="https://github.com/hunterhector/EvmEval">View the Project on GitHub <small>hunterhector/EvmEval</small></a></p>


        <ul>
          <li><a href="https://github.com/hunterhector/EvmEval/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/hunterhector/EvmEval/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/hunterhector/EvmEval">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        



<p><strong>Table of Contents</strong></p>

<ul>
<li>
<a href="#event-mention-evaluation-evmeval">Event Mention Evaluation (EvmEval)</a>

<ul>
<li><a href="#naming-convention">Naming Convention</a></li>
<li><a href="#tokenization-table-files-format">Tokenization table files format</a></li>
<li>
<a href="#scorerpy">scorer.py</a>

<ul>
<li><a href="#features"><em>Features</em></a></li>
<li><a href="#usage"><em>Usage</em></a></li>
</ul>
</li>
<li>
<a href="#validatorpy">validator.py</a>

<ul>
<li><a href="#usage-1"><em>Usage</em></a></li>
</ul>
</li>
<li>
<a href="#brat2tbfpy">brat2tbf.py</a>

<ul>
<li><a href="#features-1"><em>Features</em></a></li>
<li><a href="#usage-2"><em>Usage</em></a></li>
</ul>
</li>
<li>
<a href="#ldc-xml-to-brat-converter">LDC-XML-to-Brat converter</a>

<ul>
<li><a href="#requirements-of-the-software"><em>Requirements of the software</em></a></li>
<li><a href="#how-to-run-the-software"><em>How to run the software</em></a></li>
<li><a href="#assumptions-of-the-software">Assumptions of the software</a></li>
</ul>
</li>
<li>
<a href="#token-file-maker">Token File Maker</a>

<ul>
<li><a href="#prerequisites"><em>Prerequisites</em></a></li>
<li><a href="#usage-3"><em>Usage</em></a></li>
</ul>
</li>
<li>
<a href="#visualizepy">visualize.py</a>

<ul>
<li><a href="#text-base-visualization"><em>Text Base Visualization</em></a></li>
<li><a href="#web-base-visualization"><em>Web Base Visualization</em></a></li>
<li><a href="#usage-4"><em>Usage</em></a></li>
</ul>
</li>
</ul>
</li>
</ul>



<h1>
<a id="event-mention-evaluation-evmeval" class="anchor" href="#event-mention-evaluation-evmeval" aria-hidden="true"><span class="octicon octicon-link"></span></a>Event Mention Evaluation (EvmEval)</h1>

<p>This repository conducts, file conversion, and scoring for event mention detection. It consists of the following three pieces of code:</p>

<ol>
<li>A simple converter from Brat annotation tool format to CMU detection format</li>
<li>A scorer that can score system performance based on CMU detection format</li>
<li>A visualizer that use Embedded Brat Viewer (not actively maintained)</li>
</ol>

<p>To use the software, we need to prepare the CMU format annotation file from the Brat annotation output using "brat2tbf.py". The scorer can then take 2 documents in such format, one as gold standard data, one as system output. The scorer also need the token files produced by the tokenizer. The usage of these codes are described below. </p>

<p>Use the example shell scripts "example_run.sh" to perform all the above steps in the sample documents, if success, you will find scoring results in the example_data directory </p>

<h2>
<a id="naming-convention" class="anchor" href="#naming-convention" aria-hidden="true"><span class="octicon octicon-link"></span></a>Naming Convention</h2>

<p>The following scripts need to find corresponding files by docid and file extension, so the file extension will be provided exactly. The script have default values for these extensions, but may require additional argument if extensions are changed.</p>

<p>Here is how to find the extension:</p>

<p>For tokenization table, they normally have the following name:</p>

<pre><code>&lt;docid&gt;.tab
</code></pre>

<p>In such case, the file extension is ".tab", both the converter and scorer assume this as a default extension. If not, change them with "-te" argument.</p>

<p>For brat annotation files, they normally have the following name:</p>

<pre><code>&lt;docid&gt;.ann
</code></pre>

<p>In such case, the file extension is ".ann", the converter assume this as the default extention. If not, change it with "-ae" argument</p>

<h2>
<a id="tokenization-table-files-format" class="anchor" href="#tokenization-table-files-format" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tokenization table files format</h2>

<p>These are tab-delimited files which map the tokens to their tokenized files. A mapping table contains 3 columns for each row, and the rows contain an orderd listing of the
document's tokens. The columns are:</p>

<ul>
<li>token_id:   A string of "t" followed by a token-number beginning at 0</li>
<li>token_str:  The literal string of a given-token</li>
<li>tkn_begin:  Index of the token's first character in the tkn file</li>
<li>tkn_end:    Index of the token's last character in the tkn file</li>
</ul>

<p>Please note that all 4 fields are required and will be used:</p>

<ul>
<li>The converter will use token_id, tkn_begin, tkn_end to convert characters to token id</li>
<li>The scorer will use the token_str to detect invisible words </li>
</ul>

<p>The tokenization table files are created using our <a href="#token-file-maker">automatic tool</a>, which wraps the Stanford tokenizer and provide boundary checks.</p>

<h2>
<a id="scorerpy" class="anchor" href="#scorerpy" aria-hidden="true"><span class="octicon octicon-link"></span></a>scorer.py</h2>

<p>The current scorer can score event mention detection and coreference based on the (.tbf) format. It also require the token table files to detect invisible words and to generate
CoNLL style coreference files.</p>

<h3>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Features</em>
</h3>

<ol>
<li>Produce F1-like scoring by mapping system mentions to gold standard mentions,
read the scoring documentation for more details.</li>
<li>Be able to produce a comparison output indicating system and gold standard differences:
a. A text based comparison output (-d option)
b. A web based comparison output using Brat's embedded visualization (-v option)</li>
<li>If specified, it will generate temporary conll format files, and use the conll reference-scorer to produce coreference scores</li>
</ol>

<h3>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Usage</em>
</h3>

<pre><code>usage: scorer_vX.X.py [-h] -g GOLD -s SYSTEM [-d COMPARISON_OUTPUT]
                      [-o OUTPUT] [-c COREF] -t TOKEN_PATH [-of OFFSET_FIELD]
                      [-te TOKEN_TABLE_EXTENSION] [-b]
</code></pre>

<p>Event mention scorer, which conducts token based scoring, system and gold standard files should follows the token-based format.</p>

<pre><code>Required Arguments:
  -g GOLD, --gold GOLD  Golden Standard
  -s SYSTEM, --system SYSTEM
                        System output
  -t TOKEN_PATH, --token_path TOKEN_PATH
                        Path to the directory containing the token mappings
                        file   
Optional Arguments:
  -h, --help            show this help message and exit                                                    
  -d COMPARISON_OUTPUT, --comparison_output COMPARISON_OUTPUT
                        Compare and help show the difference between system
                        and gold
  -o OUTPUT, --output OUTPUT
                        Optional evaluation result redirects, put eval result
                        to file
  -c COREF, --coref COREF
                        Eval Coreference result output, need to put the
                        referenceconll coref scorer in the same folder with
                        this scorer
  -of OFFSET_FIELD, --offset_field OFFSET_FIELD
                        A pair of integer indicates which column we should
                        read the offset in the token mapping file, index
                        startsat 0, default value will be [2, 3]
  -te TOKEN_TABLE_EXTENSION, --token_table_extension TOKEN_TABLE_EXTENSION
                        any extension appended after docid of token table
                        files. Default is [.txt.tab]
  -ct COREFERENCE_THRESHOLD, --coreference_threshold COREFERENCE_THRESHOLD
                        Threshold for coreference mention mapping                            
  -b, --debug           turn debug mode on
</code></pre>

<h2>
<a id="validatorpy" class="anchor" href="#validatorpy" aria-hidden="true"><span class="octicon octicon-link"></span></a>validator.py</h2>

<p>The validator check whether the supplied "tbf" file follows assumed structure . </p>

<h3>
<a id="usage-1" class="anchor" href="#usage-1" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Usage</em>
</h3>

<pre><code>validator.py [-h] -s SYSTEM -t TOKEN_PATH [-of OFFSET_FIELD]
                    [-te TOKEN_TABLE_EXTENSION] [-b]

Event mention scorer, which conducts token based scoring, system and gold
standard files should follows the token-based format.

optional arguments:
  -h, --help            show this help message and exit
  -s SYSTEM, --system SYSTEM
                        System output
  -t TOKEN_PATH, --token_path TOKEN_PATH
                        Path to the directory containing the token mappings
                        file
  -of OFFSET_FIELD, --offset_field OFFSET_FIELD
                        A pair of integer indicates which column we should
                        read the offset in the token mapping file, index
                        startsat 0, default value will be [2, 3]
  -te TOKEN_TABLE_EXTENSION, --token_table_extension TOKEN_TABLE_EXTENSION
                        any extension appended after docid of token table
                        files. Default is [.txt.tab]
  -b, --debug           turn debug mode on
</code></pre>

<h2>
<a id="brat2tbfpy" class="anchor" href="#brat2tbfpy" aria-hidden="true"><span class="octicon octicon-link"></span></a>brat2tbf.py</h2>

<p>This is a tool that converts Brat Annotation format to TBF format. We currently try to make as little assumption as possible. However, in order to resolve
coreference transitive redirect automatically, the relation name for coreference must be named as "Coreference". We also develop for event coreference only.</p>

<h3>
<a id="features-1" class="anchor" href="#features-1" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Features</em>
</h3>

<ol>
<li>ID convention</li>
</ol>

<p>The default set up follows Brat v1.3 ID convention: </p>

<ul>
<li>T: text-bound annotation</li>
<li>R: relation</li>
<li>E: event</li>
<li>A: attribute</li>
<li>M: modification (alias for attribute, for backward compatibility)</li>
<li>N: normalization [new in v1.3 of Brat]</li>
<li>#: note</li>
</ul>

<p>Further development might allow customized ID convention.</p>

<ol>
<li><p>This code only scan and detect event mentions and its attributes. Event arguments and entities are currently not handled. Annotations other than Event Mention (with its attributes and Text Spans) will be ignored, which means, it will only read "E" annotations and its related attributes.</p></li>
<li><p>Discontinuous text-bound annotations will be supported</p></li>
</ol>

<h3>
<a id="usage-2" class="anchor" href="#usage-2" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Usage</em>
</h3>

<pre><code>brat2tokenFormat.py [-h] (-d DIR | -f FILE) -t TOKENPATH [-o OUT]
                       [-oe EXT] [-i EID] [-w] [-te TOKEN_TABLE_EXTENSION]
                       [-ae ANNOTATION_EXTENSION] [-b]
</code></pre>

<p>This converter converts Brat annotation files to one single token based event mention description file (CMU format). It accepts a single file name or a directory name that contains the Brat annotation output. The converter also requires token offset files that shares the same name with the annotation file, with extension .txt.tab. The converter will search for the token file in    the directory specified by '-t' argument</p>

<pre><code>Required Arguments:
  -d DIR, --dir DIR     directory of the annotation files
  -f FILE, --file FILE  name of one annotation file
  -t TOKENPATH, --tokenPath TOKENPATH
                    directory to search for the corresponding token files

Optional arguments:
  -h, --help            show this help message and exit
  -o OUT, --out OUT     output path, 'converted' in the current path by
                        default
  -oe EXT, --ext EXT    output extension, 'tbf' by default
  -i EID, --eid EID     an engine id that will appears at each line of the
                        output file. 'brat_conversion' will be used by default
  -w, --overwrite       force overwrite existing output file
  -te TOKEN_TABLE_EXTENSION, --token_table_extension TOKEN_TABLE_EXTENSION
                        any extension appended after docid of token table
                        files. Default is .txt.tab
  -ae ANNOTATION_EXTENSION, --annotation_extension ANNOTATION_EXTENSION
                        any extension appended after docid of annotation
                        files. Default is .tkn.ann
  -b, --debug           turn debug mode on
</code></pre>

<h2>
<a id="ldc-xml-to-brat-converter" class="anchor" href="#ldc-xml-to-brat-converter" aria-hidden="true"><span class="octicon octicon-link"></span></a>LDC-XML-to-Brat converter</h2>

<p>This software converts LDC's XML format for the <a href="http://cairo.lti.cs.cmu.edu/kbp/2015/event/">TAC KBP 2015 Event Nugget task</a> to the <a href="http://brat.nlplab.org/standoff.html">Brat format</a>.  More specifically, it converts LDC's event nuggets and coreferences to events and coreference links that can be viewed via the Brat web interface.  Brat annotation configurations for output are available at directory <code>src/main/resources/</code>.</p>

<h2>
<a id="requirements-of-the-software" class="anchor" href="#requirements-of-the-software" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements of the software</h2>

<p>The software requires Java 1.8 and <a href="http://junaraki.net/software/annobase">Annobase</a> 1.0.1.  See <code>pom.xml</code> for other dependencies.</p>

<h2>
<a id="how-to-run-the-software" class="anchor" href="#how-to-run-the-software" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to run the software</h2>

<p>You can see its usage with the following command:</p>

<pre><code>$ java -jar target/converter-1.0.1-jar-with-dependencies.jar
Option                            Description              
------                            -----------              
-t &lt;text dir&gt;                     text directory           
--te &lt;text file extension&gt;        text file extension      
-a &lt;annotation dir&gt;               annotation directory     
--ae &lt;annotation file extension&gt;  annotation file extension
-o &lt;output dir&gt;                   output directory         
-d                                whether to detag text    
-h                                help                     
</code></pre>

<h2>
<a id="token-file-maker" class="anchor" href="#token-file-maker" aria-hidden="true"><span class="octicon octicon-link"></span></a>Token File Maker</h2>

<h3>
<a id="requirements-of-the-file-maker" class="anchor" href="#requirements-of-the-file-maker" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Requirements of the file maker</em>
</h3>

<p>The software requires Java 1.8. A precompiled jar locates at bin directory. To compile the project from source you will also need Maven 2.7+.</p>

<h3>
<a id="prerequisites" class="anchor" href="#prerequisites" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Prerequisites</em>
</h3>

<p>Our tokenizer implementation is based on the tokenizer in the Stanford CoreNLP tool .  The software is implemented in Java, and its requirements are as follows:</p>

<ol>
<li>Java 1.8</li>
<li>The same number of text files and brat annotation files (*.ann) with the same file base name</li>
</ol>

<h3>
<a id="usage-3" class="anchor" href="#usage-3" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Usage</em>
</h3>

<pre><code>java -jar bin/token-file-maker-1.0.3-jar-with-dependencies.jar -a &lt;annotation&gt; -e &lt;extension&gt; [-h] -o &lt;output&gt; [-s &lt;separator&gt;] -t &lt;text&gt;
    -a &lt;annotation&gt;   annotation directory
    -e &lt;extension&gt;    text file extension
    -h                print this message
    -o &lt;output&gt;       output directory
    -s &lt;separator&gt;    separator chars for tokenization
    -t &lt;text&gt;         text directory
</code></pre>

<h2>
<a id="visualizepy" class="anchor" href="#visualizepy" aria-hidden="true"><span class="octicon octicon-link"></span></a>visualize.py</h2>

<p>The visualization is provided as a mechanism to compare different output, which is optional and can be ignored if one is only interested in the scores. This code maybe update frequently. Please refer to the command line "-h" for detailed instructions.</p>

<p>The visualize code represent mention differences in JSON, which is then passed to <a href="http://brat.nlplab.org/embed.html">Embedded Brat</a> .  </p>

<p>Recent changes make visualizing clusters possible by creating additional JSON object. When enabled, there will be a cluster selector on the webpage, one could select the cluster and all other event mentions will hide.</p>

<h3>
<a id="text-base-visualization" class="anchor" href="#text-base-visualization" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Text Base Visualization</em>
</h3>

<p>The text based Visualization can be generated using the "scorer.py", by supplying the "-d"
argument. The format is straightforward, a text document is produced for comparison.
The annotation of both systems are displayed in one line, separated by "|"</p>

<h3>
<a id="web-base-visualization" class="anchor" href="#web-base-visualization" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Web Base Visualization</em>
</h3>

<p>The web base visualization takes the text visualization file, then: </p>

<ol>
<li>convert them to Brat Embedded JSON format and store it at the visualization 
folder (visualization/json)</li>
<li>It will start a server at the visualization folder using localhost:8000</li>
<li>Now user can browse the locally hosted site for comparison</li>
<li>User can stop the server when done, and restart it at anytime using "start.sh", it is 
no longer necessary to regenerate the JSON data if one only wish to use the old ones</li>
</ol>

<h3>
<a id="usage-4" class="anchor" href="#usage-4" aria-hidden="true"><span class="octicon octicon-link"></span></a><em>Usage</em>
</h3>

<pre><code>usage: visualize.py [-h] -d COMPARISON_OUTPUT -t TOKENPATH [-x TEXT]
                [-v VISUALIZATION_HTML_PATH] [-of OFFSET_FIELD]
                [-te TOKEN_TABLE_EXTENSION] [-se SOURCE_FILE_EXTENSION]
</code></pre>

<p>Mention visualizer, will create a side-by-side embedded visualization from the
mapping</p>

<pre><code>Required Arguments:
  -d COMPARISON_OUTPUT, --comparison_output COMPARISON_OUTPUT
                        The comparison output file between system and gold,
                        used to recover the mapping
  -t TOKENPATH, --tokenPath TOKENPATH
                        Path to the directory containing the token mappings
                        file
Optional Arguments:
  -h, --help            show this help message and exit                    
  -x TEXT, --text TEXT  Path to the directory containing the original text
  -v VISUALIZATION_HTML_PATH, --visualization_html_path VISUALIZATION_HTML_PATH
                        The Path to find visualization web pages, default path
                        is [visualization]
  -of OFFSET_FIELD, --offset_field OFFSET_FIELD
                        A pair of integer indicates which column we should
                        read the offset in the token mapping file, index
                        startsat 0, default value will be [2, 3]
  -te TOKEN_TABLE_EXTENSION, --token_table_extension TOKEN_TABLE_EXTENSION
                        any extension appended after docid of token table
                        files. Default is [.txt.tab]
  -se SOURCE_FILE_EXTENSION, --source_file_extension SOURCE_FILE_EXTENSION
                        any extension appended after docid of source
                        files.Default is [.tkn.txt]
</code></pre>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/hunterhector">hunterhector</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-62709601-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
